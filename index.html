<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HTMLPlayer</title>
  <link rel="shortcut icon" type="image/x-icon" href="favicon.png">
  <link rel="apple-touch-icon" href="/favicon.png">
  <link rel="manifest" href="manifest.json">
  <!-- Include jsmediatags for ID3 parsing -->
  <script src="https://unpkg.com/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>
  <style>
    /* Global Reset & Base Styles */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #121212;
      color: #f1f1f1;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }
    header {
      background: linear-gradient(90deg, #2196F3, #21CBF3);
      padding: 15px 20px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      border-bottom-left-radius: 10px;
      border-bottom-right-radius: 10px;
    }
    #container {
      display: flex;
      height: calc(100vh - 60px);
    }
    /* Playlist Panel */
    #playlistPanel {
      width: 280px;
      height: 75%;/* added to prevent the music player from overlapping */
      background: #1c1c1c;
      padding: 15px;
      border-right: 1px solid #333;
      overflow-y: auto;
      border-top-left-radius: 10px;
      border-bottom-left-radius: 10px;
    }
    #playlistPanel h2 {
      font-size: 20px;
      margin-bottom: 10px;
      border-bottom: 1px solid #333;
      padding-bottom: 5px;
    }
    #playlistPanel ul { list-style: none; margin-bottom: 15px; }
    #playlistPanel li {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      margin-bottom: 5px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
      position: relative;
    }
    #playlistPanel li:hover,
    #playlistPanel li.active { background: #333; }
    #playlistPanel li img {
      width: 40px; height: 40px;
      border-radius: 6px;
      margin-right: 10px;
      object-fit: cover;
    }
    /* Checkbox for bulk delete playlists */
    .playlist-checkbox { margin-right: 5px; }
    /* Delete button for individual playlist */
    .delete-playlist {
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      color: #e53935;
      cursor: pointer;
      font-size: 16px;
    }
    #newPlaylistName {
      width: calc(100% - 20px);
      padding: 6px 8px;
      border: none;
      border-radius: 6px;
      margin-bottom: 5px;
      background: #333;
      color: #f1f1f1;
    }
    #addPlaylist, #setPlaylistArt, #togglePlaylistBulk {
      width: 100%;
      padding: 8px;
      border: none;
      background: #2196F3;
      color: #fff;
      font-size: 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      margin-bottom: 5px;
    }
    #addPlaylist:hover, #setPlaylistArt:hover, #togglePlaylistBulk:hover {
      background: #1976D2;
    }
    /* Bulk controls container (playlists) */
    #playlistBulkControls {
      display: none;
      margin-bottom: 5px;
    }
    #playlistBulkControls button {
      width: 48%;
      padding: 6px;
      margin-right: 4%;
      border: none;
      background: #e53935;
      color: #fff;
      font-size: 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #playlistBulkControls button:hover { background: #c62828; }
    /* Main Player Area */
    #mainPlayer {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 15px;
      padding-bottom: 120px;
      position: relative;
      border-top-right-radius: 10px;
      border-bottom-right-radius: 10px;
    }
    /* Toggle Bulk Delete for Tracks */
    #toggleTrackBulk {
      width: 180px;
      padding: 6px;
      border: none;
      background: #2196F3;
      color: #fff;
      font-size: 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      margin-bottom: 5px;
      align-self: center;
    }
    #toggleTrackBulk:hover { background: #1976D2; }
    /* Bulk controls container (tracks) */
    #trackBulkControls {
      display: none;
      margin-bottom: 5px;
      align-self: center;
    }
    #trackBulkControls button {
      width: 48%;
      padding: 6px;
      margin-right: 4%;
      border: none;
      background: #e53935;
      color: #fff;
      font-size: 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #trackBulkControls button:hover { background: #c62828; }
    /* Track List */
    #trackList {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 50px;/* made larger to prevent overlapping */ 
      padding-right: 5px;
    }
    #tracks { list-style: none; }
    #tracks li {
      display: flex;
      align-items: center;
      padding: 8px;
      margin-bottom: 5px;
      background: #1e1e1e;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
      position: relative;
    }
    #tracks li:hover, #tracks li.active { background: #2a2a2a; }
    #tracks li img {
      width: 40px; height: 40px;
      border-radius: 6px;
      object-fit: cover;
      margin-right: 10px;
    }
    .track-info { flex: 1; font-size: 16px; }
    /* Checkbox for bulk delete tracks */
    .track-checkbox { margin-right: 5px; }
    /* Delete button for individual track */
    .delete-track {
      background: transparent;
      border: none;
      color: #e53935;
      cursor: pointer;
      font-size: 16px;
      margin-left: 5px;
    }
    /* Rating buttons */
    .rating-btn {
      background: none;
      border: none;
      cursor: pointer;
      margin-left: 5px;
      width: 24px;
      height: 24px;
      transition: transform 0.2s;
    }
    .rating-btn:hover { transform: scale(1.2); }
    .rating-btn svg { width: 100%; height: 100%; fill: #f1f1f1; }
    /* Controls Container to Group Playback and Volume */
    #playerControls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      align-items: center;
      justify-content: center; /* Center the innerControls */
      background: #1c1c1c;
      padding: 8px 0;
      z-index: 3;
    }
    /* Inner Controls to Keep Centered */
    #innerControls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      flex: 1; /* Take up available space for proper centering */
      max-width: calc(100% - 140px); /* Ensure it doesn't overlap with currentTrackArt */
    }
    /* Current Track Art (Inside Controls, Aligned with Playlists) */
    #currentTrackArt {
      position: absolute;
      left: 20px; /* Match playlistPanel padding */
      top: 50%;
      transform: translateY(-50%);
      width: 100px;
      height: 100px;
      border-radius: 10px;
      background: #1c1c1c; /* Match playlistPanel background */
      border: 1px solid #333; /* Match playlistPanel border */
      overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
      z-index: 2;
    }
    #currentTrackArt img {
      width: 100%; height: 100%; object-fit: cover;
    }
    /* Controls */
    #controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: clamp(15px, 2vw, 25px); /* Increased and variable gap */
      margin-bottom: 5px;
    }
    #controls button {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
      position: relative; /* For positioning indicator dots */
    }
    #controls button:hover { background: rgba(255,255,255,0.1); }
    .icon { width: 32px; height: 32px; fill: #fff; }
    /* Toggle Buttons for Shuffle and Repeat */
    .toggle-btn.active { background: rgba(33,150,243,0.3); }
    /* Ensure shuffle and repeat button icons are white */
    #shuffleBtn .icon, #repeatBtn .icon {
      fill: #fff !important;
      stroke: #fff !important;
    }
    #shuffleBtn.active .icon, #repeatBtn.active .icon {
      fill: #fff !important;
      stroke: #fff !important;
    }
    /* Indicator Dot for Active State */
    .indicator-dot {
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      display: none;
    }
    .toggle-btn.active .indicator-dot { display: block; }
    /* Progress Bar */
    #progressContainer {
      width: 70vw; /* Variable width based on viewport */
      max-width: 800px; /* Increased cap */
      height: 8px;
      background: #333;
      border-radius: 4px;
      margin: 0 auto 5px auto;
      cursor: pointer;
      position: relative;
    }
    #progress {
      background: #2196F3;
      height: 100%;
      width: 0%;
      border-radius: 4px;
      transition: width 0.1s;
    }
    /* Time Display */
    #timeDisplay {
      text-align: center;
      font-size: 14px;
      margin-bottom: 5px;
    }
    /* Volume Slider */
    #volumeContainer {
      width: 30vw; /* Variable width based on viewport */
      max-width: 300px; /* Increased cap */
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 3;
    }
    #volumeSlider { width: 100%; }
    /* Hidden file input elements */
    #fileInput, #playlistArtInput { display: none; }
    /* Combined Upload/Directory Button - now labeled "Add Music" */
    #uploadBtn {
      position: absolute;
      top: 15px;
      right: 15px;
      background: #2196F3;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
      z-index: 2;
    }
    #uploadBtn:hover { background: #1976D2; }
    /* Progress Popups */
    #addingPopup, #processingPopup {
      position: fixed;
      left: 20px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 10px 15px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 1000;
      display: none;
    }
    #addingPopup { bottom: 60px; }
    #processingPopup { bottom: 20px; }
    /* Media Queries for Responsive Design */
    @media (max-width: 768px) {
      #playlistPanel {
        width: 200px;
        padding: 10px;
      }
      #playlistPanel h2 {
        margin-bottom: 8px;
        padding-bottom: 4px;
      }
      #playlistPanel li {
        padding: 5px 6px;
        margin-bottom: 4px;
      }
      #newPlaylistName {
        padding: 5px 6px;
        margin-bottom: 4px;
      }
      #addPlaylist, #setPlaylistArt, #togglePlaylistBulk {
        padding: 6px;
        font-size: 13px;
        margin-bottom: 4px;
      }
      #mainPlayer {
        padding: 10px;
        padding-bottom: 100px;
      }
      #trackList {
        margin-bottom: 8px;
        padding-right: 4px;
      }
      #tracks li {
        padding: 6px;
        margin-bottom: 4px;
      }
      #tracks li img {
        width: 36px;
        height: 36px;
      }
      #playerControls {
        padding: 6px 0;
      }
      #currentTrackArt {
        width: 80px;
        height: 80px;
        left: 15px; /* Match reduced playlistPanel padding */
      }
      #innerControls { 
        gap: 6px; 
        max-width: calc(100% - 110px); /* Adjust for smaller art */
      }
      #controls {
        gap: clamp(12px, 1.8vw, 20px); /* Adjusted variable gap */
        margin-bottom: 4px;
      }
      #progressContainer {
        width: 80vw; /* Adjusted variable width */
        max-width: 500px; /* Adjusted cap */
        margin-bottom: 4px;
      }
      #volumeContainer {
        width: 35vw; /* Adjusted variable width */
        max-width: 250px; /* Adjusted cap */
        gap: 6px;
      }
      .icon { width: 28px; height: 28px; }
      #toggleTrackBulk {
        width: 160px;
        padding: 5px;
      }
    }
    @media (max-width: 480px) {
      #playlistPanel {
        width: 150px;
        padding: 8px;
      }
      #playlistPanel h2 {
        margin-bottom: 6px;
        padding-bottom: 3px;
      }
      #playlistPanel li {
        padding: 4px 5px;
        margin-bottom: 3px;
      }
      #newPlaylistName {
        padding: 4px 5px;
        margin-bottom: 3px;
      }
      #addPlaylist, #setPlaylistArt, #togglePlaylistBulk {
        padding: 5px;
        font-size: 12px;
        margin-bottom: 3px;
      }
      #mainPlayer {
        padding: 8px;
        padding-bottom: 80px;
      }
      #trackList {
        margin-bottom: 6px;
        padding-right: 3px;
      }
      #tracks li {
        padding: 5px;
        margin-bottom: 3px;
      }
      #tracks li img {
        width: 32px;
        height: 32px;
      }
      #playerControls {
        padding: 5px 0;
      }
      #currentTrackArt {
        width: 60px;
        height: 60px;
        left: 10px; /* Match reduced playlistPanel padding */
      }
      #innerControls { 
        gap: 5px; 
        max-width: calc(100% - 80px); /* Adjust for smaller art */
      }
      #controls {
        gap: clamp(10px, 1.5vw, 15px); /* Adjusted variable gap */
        margin-bottom: 3px;
      }
      #progressContainer {
        width: 85vw; /* Adjusted variable width */
        max-width: 350px; /* Adjusted cap */
        margin-bottom: 3px;
      }
      #volumeContainer {
        width: 40vw; /* Adjusted variable width */
        max-width: 180px; /* Adjusted cap */
        gap: 5px;
      }
      .icon { width: 24px; height: 24px; }
      #toggleTrackBulk {
        width: 140px;
        padding: 4px;
      }
    }
  </style>
</head>
<body>
  <header>HTMLPlayer</header>
  <div id="container">
    <!-- Playlist Panel -->
    <div id="playlistPanel">
      <h2>Playlists</h2>
      <ul id="playlistNames"></ul>
      <input type="text" id="newPlaylistName" placeholder="New Playlist Name">
      <button id="addPlaylist">Add Playlist</button>
      <button id="setPlaylistArt">Set Playlist Art</button>
      <input type="file" id="playlistArtInput" accept="image/*">
      <button id="togglePlaylistBulk">Toggle Bulk Delete</button>
      <div id="playlistBulkControls">
        <button id="deleteSelectedPlaylists">Delete Selected</button>
        <button id="deleteAllPlaylists">Delete All</button>
      </div>
    </div>
    
    <!-- Main Player Area -->
    <div id="mainPlayer">
      <button id="toggleTrackBulk">Toggle Bulk Delete Tracks</button>
      <div id="trackBulkControls">
        <button id="deleteSelectedTracks">Delete Selected</button>
        <button id="deleteAllTracks">Delete All</button>
      </div>
      <div id="trackList">
        <ul id="tracks"></ul>
      </div>
      <!-- Grouped Player Controls -->
      <div id="playerControls">
        <!-- Current Track Art (Now Inside Controls) -->
        <div id="currentTrackArt">
          <img id="currentArtImg" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiMzMzMiIC8+PGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTAwIiB5Mj0iMTAwIiBzdHJva2U9IiNmMWYxZjEiIHN0cm9rZS13aWR0aD0iNSIgLz48bGluZSB4MT0iMTAwIiB5MT0iMCIgeDI9IjAiIHkyPSIxMDAiIHN0cm9rZT0iI2YxZjFmMSIgc3Ryb2tlLXdpZHRoPSI1IiAvPjwvc3ZnPg==" alt="No Art">
        </div>
        <!-- Inner Controls -->
        <div id="innerControls">
          <div id="controls">
            <button id="shuffleBtn" title="Shuffle" class="toggle-btn">
              <svg class="icon" viewBox="0 0 24 24">
                <path d="M4,4 L10,4 L14,10 L10,16 L4,16" fill="none" stroke="#fff" stroke-width="2"/>
                <polyline points="14,4 20,4 20,10" fill="none" stroke="#fff" stroke-width="2"/>
                <polyline points="14,16 20,16 20,20" fill="none" stroke="#fff" stroke-width="2"/>
              </svg>
              <svg class="indicator-dot" viewBox="0 0 8 8">
                <circle cx="4" cy="4" r="4" fill="#2196F3"/>
              </svg>
            </button>
            <button id="prevBtn" title="Previous">
              <svg class="icon" viewBox="0 0 24 24">
                <polygon points="15,18 9,12 15,6" />
              </svg>
            </button>
            <button id="playPauseBtn" title="Play/Pause">
              <svg class="icon" id="playIcon" viewBox="0 0 24 24">
                <polygon points="8,5 19,12 8,19" />
              </svg>
              <svg class="icon" id="pauseIcon" viewBox="0 0 24 24" style="display:none;">
                <rect x="6" y="5" width="4" height="14"/>
                <rect x="14" y="5" width="4" height="14"/>
              </svg>
            </button>
            <button id="nextBtn" title="Next">
              <svg class="icon" viewBox="0 0 24 24">
                <polygon points="9,6 15,12 9,18" />
              </svg>
            </button>
            <button id="repeatBtn" title="Repeat" class="toggle-btn">
              <svg class="icon" viewBox="0 0 24 24">
                <path d="M17 1l4 4-4 4M7 23l-4-4 4-4" fill="none" stroke="#fff" stroke-width="2"/>
                <path d="M3 11V9a4 4 0 0 1 4-4h10" fill="none" stroke="#fff" stroke-width="2"/>
                <path d="M21 13v2a4 4 0 0 1-4 4H7" fill="none" stroke="#fff" stroke-width="2"/>
              </svg>
              <svg class="indicator-dot" viewBox="0 0 8 8">
                <circle cx="4" cy="4" r="4" fill="#2196F3"/>
              </svg>
            </button>
          </div>
          <div id="progressContainer">
            <div id="progress"></div>
          </div>
          <div id="timeDisplay">0:00 / 0:00</div>
          <div id="volumeContainer">
            <svg class="icon" viewBox="0 0 24 24">
              <polygon points="5,9 9,9 13,5 13,19 9,15 5,15" />
            </svg>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5">
          </div>
        </div>
      </div>
      
      <!-- Combined Button labeled "Add Music" -->
      <button id="uploadBtn">Add Music</button>
      <input type="file" id="fileInput" accept="audio/mp3, audio/ogg, audio/m4a" multiple>
      <button id="install-button" hidden>Install App</button>
    </div>
  </div>
  
  <!-- Popups for Adding and Processing -->
  <div id="addingPopup">Adding... 0 entries</div>
  <div id="processingPopup">Processing... 0/0</div>
  <audio id="audio" preload="metadata"></audio>
  
  <script>
    /* ---------- IndexedDB Setup ---------- */
    let db;
    const dbName = "MusicPlayerDB";
    const dbVersion = 1;
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, dbVersion);
        request.onerror = () => reject("Error opening DB");
        request.onsuccess = (e) => { db = e.target.result; resolve(db); };
        request.onupgradeneeded = (e) => {
          db = e.target.result;
          if (!db.objectStoreNames.contains("playlists")) {
            db.createObjectStore("playlists", { keyPath: "name" });
          }
          if (!db.objectStoreNames.contains("ratings")) {
            db.createObjectStore("ratings", { keyPath: "id" });
          }
          if (!db.objectStoreNames.contains("settings")) {
            db.createObjectStore("settings", { keyPath: "key" });
          }
        };
      });
    }
    
    /* ---------- IndexedDB: Rating Functions ---------- */
    function saveRating(trackId, rating) {
      const transaction = db.transaction(["ratings"], "readwrite");
      const store = transaction.objectStore("ratings");
      store.put({ id: trackId, rating });
    }
    function getRating(trackId) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(["ratings"], "readonly");
        const store = transaction.objectStore("ratings");
        const request = store.get(trackId);
        request.onsuccess = (e) => { resolve(e.target.result ? e.target.result.rating : 0); };
        request.onerror = () => reject(0);
      });
    }
    
    /* ---------- IndexedDB: Settings Functions ---------- */
    function saveSetting(key, value) {
      const transaction = db.transaction(["settings"], "readwrite");
      const store = transaction.objectStore("settings");
      store.put({ key, value });
    }
    function loadSetting(key) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(["settings"], "readonly");
        const store = transaction.objectStore("settings");
        const request = store.get(key);
        request.onsuccess = (e) => { resolve(e.target.result ? e.target.result.value : null); };
        request.onerror = () => reject(null);
      });
    }
    
    /* ---------- Playlist Data Structure ---------- */
    let playlists = {};
    let currentPlaylist = "Default";
    let currentTrackIndex = 0;
    let tracks = []; // Current playlist's tracks
    
    /* ---------- Player State ---------- */
    let isShuffle = false;
    let isRepeat = false;
    
    /* ---------- Bulk Delete State ---------- */
    let bulkDeletePlaylists = false;
    let selectedPlaylists = new Set();
    let bulkDeleteTracks = false;
    let selectedTracks = new Set();
    
    /* ---------- UI Initialization ---------- */
    async function initPlaylists() {
      // Load settings first, without overwriting
      isShuffle = (await loadSetting("shuffle")) ?? false;
      isRepeat = (await loadSetting("repeat")) ?? false;
      const savedVolume = await loadSetting("volume") ?? 0.5;

      // Update UI after loading settings
      shuffleBtn.classList.toggle("active", isShuffle);
      repeatBtn.classList.toggle("active", isRepeat);
      volumeSlider.value = savedVolume;
      audio.volume = savedVolume;

      loadPlaylists().then((data) => {
        if (data.length === 0) {
          playlists["Default"] = { tracks: [], art: null };
          savePlaylist("Default", playlists["Default"]);
        } else {
          data.forEach(item => {
            playlists[item.name] = { tracks: item.tracks || [], art: item.art || null };
          });
        }
        renderPlaylistNames();
        loadPlaylist(currentPlaylist);
      });

      restoreDirectory();
    }
    function savePlaylist(name, playlistObj) {
      const transaction = db.transaction(["playlists"], "readwrite");
      const store = transaction.objectStore("playlists");
      store.put({ name, tracks: playlistObj.tracks, art: playlistObj.art || null });
    }
    function deletePlaylistFromDB(name) {
      const transaction = db.transaction(["playlists"], "readwrite");
      const store = transaction.objectStore("playlists");
      store.delete(name);
    }
    function loadPlaylists() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(["playlists"], "readonly");
        const store = transaction.objectStore("playlists");
        const request = store.getAll();
        request.onsuccess = (e) => resolve(e.target.result);
        request.onerror = () => reject([]);
      });
    }
    function renderPlaylistNames() {
      const playlistNamesElem = document.getElementById("playlistNames");
      playlistNamesElem.innerHTML = "";
      Object.keys(playlists).forEach(name => {
        const li = document.createElement("li");
        if(bulkDeletePlaylists) {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "playlist-checkbox";
          checkbox.checked = selectedPlaylists.has(name);
          checkbox.onchange = (e) => { if(e.target.checked) { selectedPlaylists.add(name); } else { selectedPlaylists.delete(name); } };
          li.appendChild(checkbox);
        }
        if (playlists[name].art) {
          const img = document.createElement("img");
          img.src = playlists[name].art;
          li.appendChild(img);
        }
        const span = document.createElement("span");
        span.textContent = name;
        li.appendChild(span);
        if(!bulkDeletePlaylists) {
          const delBtn = document.createElement("button");
          delBtn.className = "delete-playlist";
          delBtn.textContent = "×";
          delBtn.onclick = (e) => {
            e.stopPropagation();
            if (name === "Default") {
              alert("Cannot delete the Default playlist.");
              return;
            }
            if(confirm("Delete playlist '" + name + "'?")) {
              delete playlists[name]; // Remove from in-memory object
              deletePlaylistFromDB(name); // Remove from IndexedDB
              if(currentPlaylist === name) {
                currentPlaylist = "Default";
                loadPlaylist(currentPlaylist);
              }
              renderPlaylistNames();
            }
          };
          li.appendChild(delBtn);
        }
        li.onclick = () => {
          if(!bulkDeletePlaylists) {
            currentPlaylist = name;
            currentTrackIndex = 0;
            loadPlaylist(name);
            updateActivePlaylist();
          }
        };
        playlistNamesElem.appendChild(li);
      });
      updateActivePlaylist();
      document.getElementById("playlistBulkControls").style.display = bulkDeletePlaylists ? "block" : "none";
    }
    function updateActivePlaylist() {
      const lis = document.querySelectorAll("#playlistNames li");
      lis.forEach(li => { li.classList.toggle("active", li.textContent.trim().replace("×","") === currentPlaylist); });
    }
    function loadPlaylist(name) {
      tracks = playlists[name] ? playlists[name].tracks : [];
      renderTrackList();
      updateCurrentPlaylistArt();
    }
    function updateCurrentPlaylistArt() {
      if (playlists[currentPlaylist] && playlists[currentPlaylist].art) {
        document.getElementById("currentArtImg").src = playlists[currentPlaylist].art;
      }
    }
    
    /* ---------- Render Track List ---------- */
    function renderTrackList() {
      const trackListElem = document.getElementById("tracks");
      trackListElem.innerHTML = "";
      tracks.forEach((track, index) => {
        const li = document.createElement("li");
        li.draggable = true;
        li.dataset.index = index;
        li.ondragstart = dragStart;
        li.ondragover = dragOver;
        li.ondrop = drop;
        if(bulkDeleteTracks) {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "track-checkbox";
          checkbox.checked = selectedTracks.has(track.id);
          checkbox.onchange = (e) => { if(e.target.checked) { selectedTracks.add(track.id); } else { selectedTracks.delete(track.id); } };
          li.appendChild(checkbox);
        }
        const thumb = document.createElement("img");
        thumb.src = track.art || "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIGZpbGw9IiMzMzMiIC8+PHBhdGggZD0iTTE2IDE2aDgiIHN0cm9rZT0iI2YxZjFmMSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIiAvPjwvc3ZnPg==";
        li.appendChild(thumb);
        const titleSpan = document.createElement("span");
        titleSpan.className = "track-info";
        titleSpan.textContent = track.name;
        li.appendChild(titleSpan);
        const ratingContainer = document.createElement("div");
        const likeBtn = document.createElement("button");
        likeBtn.className = "rating-btn";
        likeBtn.title = "Like";
        likeBtn.innerHTML = `<svg viewBox="0 0 24 24">
                                <polygon points="12,17.27 18.18,21 16.54,13.97 22,9.24 14.81,8.63 12,2 9.19,8.63 2,9.24 7.46,13.97 5.82,21"/>
                              </svg>`;
        const dislikeBtn = document.createElement("button");
        dislikeBtn.className = "rating-btn";
        dislikeBtn.title = "Dislike";
        dislikeBtn.innerHTML = `<svg viewBox="0 0 24 24">
                                  <polygon points="12,6.73 5.82,3 7.46,10.03 2,14.76 9.19,15.37 12,22 14.81,15.37 22,14.76 16.54,10.03 18.18,3"/>
                                </svg>`;
        getRating(track.id).then((rating) => {
          if(rating === 1) { likeBtn.querySelector('svg').style.fill = "#2196F3"; }
          else if(rating === -1) { dislikeBtn.querySelector('svg').style.fill = "#e53935"; }
        });
        likeBtn.onclick = (e) => {
          e.stopPropagation();
          getRating(track.id).then((rating) => {
            const newRating = rating === 1 ? 0 : 1;
            saveRating(track.id, newRating);
            likeBtn.querySelector('svg').style.fill = newRating === 1 ? "#2196F3" : "#f1f1f1";
            dislikeBtn.querySelector('svg').style.fill = "#f1f1f1";
          });
        };
        dislikeBtn.onclick = (e) => {
          e.stopPropagation();
          getRating(track.id).then((rating) => {
            const newRating = rating === -1 ? 0 : -1;
            saveRating(track.id, newRating);
            dislikeBtn.querySelector('svg').style.fill = newRating === -1 ? "#e53935" : "#f1f1f1";
            likeBtn.querySelector('svg').style.fill = "#f1f1f1";
          });
        };
        ratingContainer.appendChild(likeBtn);
        ratingContainer.appendChild(dislikeBtn);
        li.appendChild(ratingContainer);
        if(!bulkDeleteTracks) {
          const delBtn = document.createElement("button");
          delBtn.className = "delete-track";
          delBtn.textContent = "×";
          delBtn.onclick = (e) => {
            e.stopPropagation();
            if(confirm("Delete track '" + track.name + "'?")) {
              tracks.splice(index, 1);
              playlists[currentPlaylist].tracks = tracks;
              savePlaylist(currentPlaylist, playlists[currentPlaylist]);
              renderTrackList();
            }
          };
          li.appendChild(delBtn);
        }
        li.onclick = () => { if(!bulkDeleteTracks){ currentTrackIndex = index; playTrack(); } };
        trackListElem.appendChild(li);
      });
      document.getElementById("trackBulkControls").style.display = bulkDeleteTracks ? "block" : "none";
    }
    
    /* ---------- Drag & Drop for Reordering ---------- */
    function dragStart(e) { e.dataTransfer.setData("text/plain", e.target.dataset.index); }
    function dragOver(e) { e.preventDefault(); }
    function drop(e) {
      e.preventDefault();
      const draggedIndex = e.dataTransfer.getData("text/plain");
      const targetLi = e.target.closest("li");
      if (!targetLi) return;
      const targetIndex = targetLi.dataset.index;
      if (draggedIndex === targetIndex) return;
      const draggedTrack = tracks.splice(draggedIndex, 1)[0];
      tracks.splice(targetIndex, 0, draggedTrack);
      playlists[currentPlaylist].tracks = tracks;
      savePlaylist(currentPlaylist, playlists[currentPlaylist]);
      renderTrackList();
    }
    
    /* ---------- Audio Controls ---------- */
    const audio = document.getElementById("audio");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const progressContainer = document.getElementById("progressContainer");
    const progressBar = document.getElementById("progress");
    const volumeSlider = document.getElementById("volumeSlider");
    const playIcon = document.getElementById("playIcon");
    const pauseIcon = document.getElementById("pauseIcon");
    const shuffleBtn = document.getElementById("shuffleBtn");
    const repeatBtn = document.getElementById("repeatBtn");
    const timeDisplay = document.getElementById("timeDisplay");
    let processedFiles = new Set();
    
    playPauseBtn.onclick = () => {
      if (audio.paused) { audio.play(); playIcon.style.display = "none"; pauseIcon.style.display = "block"; }
      else { audio.pause(); playIcon.style.display = "block"; pauseIcon.style.display = "none"; }
    };
    prevBtn.onclick = () => { currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length; playTrack(); };
    nextBtn.onclick = () => { nextTrack(); };
    shuffleBtn.onclick = () => {
      isShuffle = !isShuffle;
      shuffleBtn.classList.toggle("active", isShuffle);
      saveSetting("shuffle", isShuffle);
    };
    repeatBtn.onclick = () => {
      isRepeat = !isRepeat;
      repeatBtn.classList.toggle("active", isRepeat);
      saveSetting("repeat", isRepeat);
    };
    audio.addEventListener("timeupdate", () => {
      if (audio.duration) {
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = percent + "%";
        timeDisplay.textContent = formatTime(audio.currentTime) + " / " + formatTime(audio.duration);
      }
    });
    progressContainer.onclick = (e) => {
      const rect = progressContainer.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      audio.currentTime = (clickX / rect.width) * audio.duration;
    };
    volumeSlider.oninput = () => {
      audio.volume = volumeSlider.value;
      saveSetting("volume", volumeSlider.value); // Save volume on change
    };
    audio.onended = () => { if(isRepeat){ audio.currentTime = 0; audio.play(); } else { nextTrack(); } };
    function nextTrack() {
      if (tracks.length === 0) return;
      currentTrackIndex = isShuffle ? Math.floor(Math.random() * tracks.length) : (currentTrackIndex + 1) % tracks.length;
      playTrack();
    }
    async function playTrack() {
      if (tracks.length === 0) return;
      const track = tracks[currentTrackIndex];
      let file;
      if (track.handle) { file = await track.handle.getFile(); }
      else if (track.file) { file = track.file; }
      else { return; }
      const url = URL.createObjectURL(file);
      audio.src = url;
      audio.play();
      playIcon.style.display = "none";
      pauseIcon.style.display = "block";
      highlightCurrentTrack();
      updateCurrentTrackArt(track.art);
    }
    function highlightCurrentTrack() {
      const lis = document.querySelectorAll("#tracks li");
      lis.forEach((li, index) => {
        const isActive = index == currentTrackIndex;
        li.classList.toggle("active", isActive);
        // Auto-scroll to the active track
        if (isActive) {
          li.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      });
    }
    function updateCurrentTrackArt(art) {
      const imgElem = document.getElementById("currentArtImg");
      imgElem.src = art || (playlists[currentPlaylist].art || "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiMzMzMiIC8+PGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTAwIiB5Mj0iMTAwIiBzdHJva2U9IiNmMWYxZjEiIHN0cm9rZS13aWR0aD0iNSIgLz48bGluZSB4MT0iMTAwIiB5MT0iMCIgeDI9IjAiIHkyPSIxMDAiIHN0cm9rZT0iI2YxZjFmMSIgc3Ryb2tlLXdpZHRoPSI1IiAvPjwvc3ZnPg==");
    }
    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return m + ":" + (s < 10 ? "0" : "") + s;
    }
    
    /* ---------- File Input & ID3 Parsing for Tracks ---------- */
    document.getElementById("fileInput").onchange = (e) => {
      const files = Array.from(e.target.files);
      files.forEach(file => {
        const id = Date.now() + Math.random().toString(36).substr(2, 9);
        let track = { id, name: file.name, file, art: null };
        jsmediatags.read(file, {
          onSuccess: (tag) => {
            const tags = tag.tags;
            if(tags.title) { track.name = tags.title; }
            if(tags.picture) {
              let data = tags.picture.data, format = tags.picture.format, base64String = "";
              for (let i = 0; i < data.length; i++) { base64String += String.fromCharCode(data[i]); }
              track.art = "data:" + format + ";base64," + btoa(base64String);
            }
            addTrackToPlaylist(track);
          },
          onError: () => { addTrackToPlaylist(track); }
        });
      });
    };
    function addTrackToPlaylist(track) {
      if (tracks.some(t => t.name === track.name)) return;
      tracks.push(track);
      playlists[currentPlaylist].tracks = tracks;
      savePlaylist(currentPlaylist, playlists[currentPlaylist]);
      renderTrackList();
      
      if (track.file) {
        track.fileUrl = URL.createObjectURL(track.file);
        setTimeout(() => URL.revokeObjectURL(track.fileUrl), 5000);
      }
    }
    
    /* ---------- Combined Add/Directory Selection Button ---------- */
    document.getElementById("uploadBtn").onclick = async () => {
      if (window.showDirectoryPicker) {
        try {
          const dirHandle = await window.showDirectoryPicker();
          if (await dirHandle.requestPermission({ mode: "read" }) === "granted") {
            saveSetting("musicDirectory", dirHandle);
            await processDirectoryWithPopups(dirHandle);
          }
        } catch (error) { console.error("Directory selection cancelled or failed.", error); }
      } else {
        document.getElementById("fileInput").click();
      }
    };
    
    /* ---------- Process Directory in Batches with Two Popups ---------- */
    async function processDirectoryWithPopups(dirHandle) {
      let entries = [];
      const addingPopup = document.getElementById("addingPopup");
      addingPopup.style.display = "block";
      let entryCount = 0;
      
      for await (const entry of dirHandle.values()) {
        entryCount++;
        if (entry.kind === 'file' && (entry.name.endsWith('.mp3') || entry.name.endsWith('.ogg'))) {
          if (!processedFiles.has(entry.name)) {
            entries.push(entry);
          }
        }
        addingPopup.textContent = `Adding... ${entryCount} entries`;
      }
      addingPopup.style.display = "none";
      
      const total = entries.length;
      if (total === 0) return;
      
      const processingPopup = document.getElementById("processingPopup");
      processingPopup.style.display = "block";
      processingPopup.textContent = `Processing... 0/${total}`;
      
      const batchSize = Math.max(5, Math.floor(total / 10));
      for (let i = 0; i < total; i += batchSize) {
        const batch = entries.slice(i, i + batchSize);
        await Promise.all(batch.map(async (entry) => {
          try {
            const file = await entry.getFile();
            if (processedFiles.has(file.name)) return;
            processedFiles.add(file.name);
            
            const id = Date.now() + Math.random().toString(36).substr(2, 9);
            let track = { id, name: file.name, handle: entry, art: null };
            
            await new Promise((resolve) => {
              jsmediatags.read(file, {
                onSuccess: (tag) => {
                  if (tag.tags.title) track.name = tag.tags.title;
                  if (tag.tags.picture) {
                    let data = tag.tags.picture.data, format = tag.tags.picture.format, base64String = "";
                    for (let j = 0; j < data.length; j++) base64String += String.fromCharCode(data[j]);
                    track.art = "data:" + format + ";base64," + btoa(base64String);
                  }
                  resolve();
                },
                onError: () => resolve()
              });
            });
            addTrackToPlaylist(track);
          } catch (err) {
            console.error("Error reading file", err);
          }
        }));
        
        processingPopup.textContent = `Processing... ${Math.min(i + batchSize, total)}/${total}`;
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      processingPopup.style.display = "none";
    }
    async function restoreDirectory() {
      try {
        const storedFiles = await loadSetting("processedFiles");
        if (storedFiles) {
          processedFiles = new Set(storedFiles);
        }
      } catch (err) {
        console.error("Error restoring processed files", err);
      }
    }

    /* ---------- Playlist Art Upload ---------- */
    document.getElementById("setPlaylistArt").onclick = () => {
      document.getElementById("playlistArtInput").click();
    };
    document.getElementById("playlistArtInput").onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        playlists[currentPlaylist].art = ev.target.result;
        savePlaylist(currentPlaylist, playlists[currentPlaylist]);
        renderPlaylistNames();
        updateCurrentPlaylistArt();
      };
      reader.readAsDataURL(file);
    };
    
    /* ---------- Bulk Delete Controls for Playlists ---------- */
    document.getElementById("togglePlaylistBulk").onclick = () => {
      bulkDeletePlaylists = !bulkDeletePlaylists;
      selectedPlaylists.clear();
      renderPlaylistNames();
    };
    document.getElementById("deleteSelectedPlaylists").onclick = () => {
      if(selectedPlaylists.size === 0) { alert("No playlists selected."); return; }
      if(confirm("Delete selected playlists?")) {
        selectedPlaylists.forEach(name => {
          if(name === "Default") return;
          delete playlists[name];
          deletePlaylistFromDB(name); // Properly delete from IndexedDB
        });
        selectedPlaylists.clear();
        if(!playlists[currentPlaylist]) { currentPlaylist = "Default"; }
        renderPlaylistNames();
        loadPlaylist(currentPlaylist);
      }
    };
    document.getElementById("deleteAllPlaylists").onclick = () => {
      if(confirm("Delete ALL playlists? (Default will be recreated)")) {
        Object.keys(playlists).forEach(name => {
          if(name !== "Default") {
            delete playlists[name];
            deletePlaylistFromDB(name); // Properly delete from IndexedDB
          }
        });
        currentPlaylist = "Default";
        renderPlaylistNames();
        loadPlaylist(currentPlaylist);
      }
    };
    
    /* ---------- Bulk Delete Controls for Tracks ---------- */
    document.getElementById("toggleTrackBulk").onclick = () => {
      bulkDeleteTracks = !bulkDeleteTracks;
      selectedTracks.clear();
      renderTrackList();
    };
    document.getElementById("deleteSelectedTracks").onclick = () => {
      if(selectedTracks.size === 0) { alert("No tracks selected."); return; }
      if(confirm("Delete selected tracks?")) {
        tracks = tracks.filter(track => !selectedTracks.has(track.id));
        playlists[currentPlaylist].tracks = tracks;
        savePlaylist(currentPlaylist, playlists[currentPlaylist]);
        selectedTracks.clear();
        renderTrackList();
      }
    };
    document.getElementById("deleteAllTracks").onclick = () => {
      if(confirm("Delete ALL tracks in this playlist?")) {
        tracks = [];
        playlists[currentPlaylist].tracks = tracks;
        savePlaylist(currentPlaylist, playlists[currentPlaylist]);
        renderTrackList();
      }
    };
    
    /* ---------- Adding New Playlist ---------- */
    document.getElementById("addPlaylist").onclick = () => {
      const name = document.getElementById("newPlaylistName").value.trim();
      if (name && !playlists[name]) {
        playlists[name] = { tracks: [], art: null };
        savePlaylist(name, playlists[name]);
        renderPlaylistNames();
        document.getElementById("newPlaylistName").value = "";
      }
    };
    
    /* ---------- Initialize Player ---------- */
    openDatabase().then(() => { 
      initPlaylists();
      restoreDirectory();
    }).catch(err => { console.error(err); });
  </script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/HTMLPlayer/service-worker.js", {
          scope: "/HTMLPlayer/"
        });
      }
  
      let deferredPrompt;
      const installButton = document.getElementById("install-button");
  
      window.addEventListener("beforeinstallprompt", (e) => {
        e.preventDefault();
        deferredPrompt = e;
        installButton.hidden = false;
      });
  
      installButton.addEventListener("click", async () => {
        const isStandalone = window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
        
        if (isStandalone) {
          console.log("App is already installed");
          return;
        }
  
        if (deferredPrompt) {
          deferredPrompt.prompt();
          const { outcome } = await deferredPrompt.userChoice;
          deferredPrompt = null;
          if (outcome === "accepted") {
            console.log("User accepted install prompt");
          } else {
            console.log("User dismissed install prompt");
          }
        } else {
          if (window.matchMedia("(display-mode: browser)").matches) {
            window.location.assign("chrome://apps/");
          }
        }
      });
    });
  </script>
</body>
</html>
